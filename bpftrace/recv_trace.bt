#!/usr/bin/env bpftrace

/* * rx_lat_hist.bt
 * Measures Receiver Latency using Histograms.
 */

/* 1. DRIVER LAYER (Start) */
tracepoint:net:netif_receive_skb
{
    $skb = (uint64)args->skbaddr;
    @rx_start[$skb] = nsecs;
}

/* 2. IP LAYER (Routing) */
kprobe:ip_local_deliver
{
    $skb = (uint64)arg0;
    if (@rx_start[$skb]) {
        @rx_ip[$skb] = nsecs;
    }
}

/* 3. SOCKET LAYER (End) - Changed to handle TCP & UDP */
kprobe:sock_queue_rcv_skb
{
    $skb = (uint64)arg1; 
    
    if (@rx_start[$skb]) {
        $start = @rx_start[$skb];
        $ip_ts = @rx_ip[$skb];
        $now = nsecs;

        if ($ip_ts != 0) {
             $drv_ip  = ($ip_ts - $start) / 1000;
             $ip_sock = ($now - $ip_ts)  / 1000;
             $total   = ($now - $start)  / 1000;
             
             @dist_Driver_to_IP_us = hist($drv_ip);
             @dist_IP_to_Socket_us = hist($ip_sock);
             @dist_Total_Latency_us = hist($total);
             
             // Separate map for the average calculation
             @avg_total_us = avg($total);
        }

        delete(@rx_start[$skb]);
        delete(@rx_ip[$skb]);
    }
}

interval:s:5 {
    time("%H:%M:%S \n");
    
    print(@dist_Driver_to_IP_us);
    print(@dist_IP_to_Socket_us);
    print(@dist_Total_Latency_us);
    
    // Correct way to print the average
    print(@avg_total_us);
    
    clear(@dist_Driver_to_IP_us);
    clear(@dist_IP_to_Socket_us);
    clear(@dist_Total_Latency_us);
    clear(@avg_total_us);

    /* Anti-leak: Clean up stale entries from dropped packets */
    clear(@rx_start);
    clear(@rx_ip);
}